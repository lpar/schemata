package schemata

import (
	"context"

	"github.com/jackc/pgx/v4"
	"github.com/jackc/pgx/v4/pgxpool"
	"fmt"
	"sync"
	"testing"
)

// Factory is an object which creates temporary schemas and populates them with copies of tables for testing purposes.
type Factory struct {
	pool         *pgxpool.Pool
	srcSchema    string
	prefix       string
	schemaNumber int
	mux          sync.Mutex
	generateIDs  bool // whether to add an integer generator to the ID column
}

// NewFactory creates a factory object for generating test schemas.
func NewFactory(pool *pgxpool.Pool, sourceSchema string, testSchemaNamePrefix string) Factory {
	return Factory{
		pool:        pool,
		srcSchema:   sourceSchema,
		prefix:      testSchemaNamePrefix,
		generateIDs: true,
	}
}

func (f *Factory) newSchemaName() string {
	f.mux.Lock()
	sn := fmt.Sprintf("%s_%d", f.prefix, f.schemaNumber)
	f.schemaNumber++
	f.mux.Unlock()
	return sn
}

// NewSchema creates a new schema, and creates tables which match the named tables in the factory's source schema.
// Returns the name of the generated schema. If anything goes wrong, it fails the test case with t.Fatal.
func (f Factory) NewSchema(t *testing.T, srcTableList ...string) string {
	t.Helper()
	tx, err := f.pool.BeginTx(context.Background(), pgx.TxOptions{})
	if err != nil {
		t.Fatal(err)
		return ""
	}
	name := f.newSchemaName()
	_, err = tx.Exec(context.Background(), "create schema " + name)
	if err != nil {
		tx.Rollback(context.Background())
		t.Fatal(err)
		return ""
	}
	_, err = tx.Exec(context.Background(), "set schema '" + name + "'")
	if err != nil {
		tx.Rollback(context.Background())
		t.Fatal(err)
		return ""
	}
	for _, tblname := range srcTableList {
		// We copy indexes and defaults, but not constraints, because constraints will still point back to the production tables,
		// which isn't useful for testing purposes. Tests should be verifying foreign key references anyway!
		sqls := fmt.Sprintf("create table %s.%s (like %s.%s including defaults including indexes excluding constraints)", name, tblname, f.srcSchema, tblname)
		_, err = tx.Exec(context.Background(), sqls)
		if err != nil {
			tx.Rollback(context.Background())
			t.Fatal(err)
			return ""
		}
		if (f.generateIDs) {
			sqls := fmt.Sprintf("alter table %s.%s" + " alter column id add generated by default as identity", name, tblname)
			_, err = tx.Exec(context.Background(), sqls)
			if err != nil {
				tx.Rollback(context.Background())
				t.Fatal(err)
				return ""
			}
		}
	}
	err = tx.Commit(context.Background())
	if err != nil {
		t.Fatal(err)
	}
	return name
}

func (f Factory) Close(t *testing.T, schema string) {
	t.Helper()
	_, err := f.pool.Exec(context.Background(), "drop schema " + schema + " cascade")
	if err != nil {
		t.Fatal(err)
	}
}
