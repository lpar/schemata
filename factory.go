package schemata

import (
	"context"
	"github.com/jmoiron/sqlx"
	"fmt"
	"sync"
	"testing"
)

// Factory is an object which creates temporary schemas and populates them with copies of tables for testing purposes.
type Factory struct {
	pool         *sqlx.DB
	srcSchema    string
	prefix       string
	schemaNumber int
	mux          sync.Mutex
	generateIDs  bool // whether to add an integer generator to the ID column
}

// NewFactory creates a factory object for generating test schemas.
func NewFactory(pool *sqlx.DB, sourceSchema string, testSchemaNamePrefix string) *Factory {
	return &Factory{
		pool:      pool,
		srcSchema: sourceSchema,
		prefix:    testSchemaNamePrefix,
		generateIDs: true,
	}
}

func (f *Factory) newSchemaName() string {
	f.mux.Lock()
	sn := fmt.Sprintf("%s_%d", f.prefix, f.schemaNumber)
	f.schemaNumber++
	f.mux.Unlock()
	return sn
}

// NewSchema creates a new schema, and creates tables which match the named tables in the factory's source schema.
// Returns the name of the generated schema. If anything goes wrong, it fails the test case with t.Fatal.
func (f *Factory) NewSchema(t *testing.T, srcTableList ...string) string {
	t.Helper()
	tx, err := f.pool.BeginTxx(context.Background(), nil)
	if err != nil {
		t.Fatal(err)
		return ""
	}
	name := f.newSchemaName()
	_, err = tx.ExecContext(context.Background(), "create schema " + name)
	if err != nil {
		tx.Rollback()
		t.Fatal(err)
		return ""
	}
	_, err = tx.ExecContext(context.Background(), "set schema '" + name + "'")
	if err != nil {
		tx.Rollback()
		t.Fatal(err)
		return ""
	}
	for _, tblname := range srcTableList {
		// We copy indexes and defaults, but not constraints, because constraints will still point back to the production tables,
		// which isn't useful for testing purposes. Tests should be verifying foreign key references anyway!
		sql := fmt.Sprintf("create table %s.%s (like %s.%s including defaults including indexes excluding constraints)", name, tblname, f.srcSchema, tblname)
		_, err = tx.ExecContext(context.Background(), sql)
		if err != nil {
			tx.Rollback()
			t.Fatal(err)
			return ""
		}
		if (f.generateIDs) {
			sql = "alter table " + tblname + " alter column id add generated by default as identity"
			_, err = tx.ExecContext(context.Background(), sql)
			if err != nil {
				tx.Rollback()
				t.Fatal(err)
				return ""
			}
		}
	}
	err = tx.Commit()
	if err != nil {
		t.Fatal(err)
	}
	return name
}

// Close deletes the test schema and all tables and data in it, and releases the connection.
func (f *Factory) oldClose(t *testing.T, conn *sqlx.Tx) {
	t.Helper()
	res := conn.QueryRowContext(context.Background(), "select current_schema()")
	var tmpname string
	err := res.Scan(&tmpname)
	if err != nil {
		t.Fatal(err)
		return
	}
	if tmpname == f.srcSchema {
		t.Fatalf("found current schema was %s (same as source schema), expected something else", tmpname)
		return
	}
	_, err = conn.ExecContext(context.Background(), "drop schema " + tmpname + " cascade")
	if err != nil {
		t.Fatal(err)
	}
}

func (f *Factory) Close(t *testing.T, schema string) {
	t.Helper()
	_, err := f.pool.ExecContext(context.Background(), "drop schema " + schema + " cascade")
	if err != nil {
		t.Fatal(err)
	}
}
